// Decompiled with JetBrains decompiler
// Type: Hacknet.HTTPExploitExe
// Assembly: Hacknet, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 44D58447-4185-43DF-BEF1-8BBDED416CAA
// Assembly location: E:\SteamLibrary\steamapps\common\Hacknet\Hacknet.exe

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;

namespace Hacknet
{
  internal class HTTPExploitExe : ExeModule
  {
    public static float DURATION = 14f;
    public static float AFTER_COMPLETION_STALL = 1f;
    public static float GRAPH_MOVEMENT = 22f;
    private float progress = 0.0f;
    private bool hasCompleted = false;
    private float sucsessTimer = HTTPExploitExe.AFTER_COMPLETION_STALL;
    private float tAccum = 0.0f;
    private float fastTimeAccum = 0.0f;
    private float heightRange = 0.0f;
    private List<Vector2> graphPoints;
    private List<Vector2> backGraphPoints;

    public HTTPExploitExe(Rectangle location, OS operatingSystem)
      : base(location, operatingSystem)
    {
      this.needsProxyAccess = true;
      this.ramCost = 208;
      this.IdentifierName = "Apache Web Server Worm";
    }

    public override void LoadContent()
    {
      base.LoadContent();
      this.graphPoints = new List<Vector2>();
      this.backGraphPoints = new List<Vector2>();
      float num1 = 6f;
      this.heightRange = (float) ((this.bounds.Height - 4 - 17) / 3) * 2f;
      int num2 = (int) ((double) (this.bounds.Width - 4) / (double) num1);
      Vector2 vector2 = new Vector2(2f, (float) (this.bounds.Height - 4 - 17));
      this.graphPoints.Add(new Vector2(vector2.X, vector2.Y));
      this.backGraphPoints.Add(new Vector2(vector2.X, vector2.Y));
      for (int index = 1; index < num2 - 1; ++index)
      {
        this.graphPoints.Add(new Vector2(vector2.X, vector2.Y - (float) (Utils.random.NextDouble() * 0.2 + 0.3) * this.heightRange));
        this.backGraphPoints.Add(new Vector2(vector2.X, vector2.Y - (float) Utils.random.NextDouble() * this.heightRange));
        vector2.X += num1;
      }
      this.graphPoints.Add(new Vector2(vector2.X, vector2.Y));
      this.backGraphPoints.Add(new Vector2(vector2.X, vector2.Y));
      Computer computer = Programs.getComputer(this.os, this.targetIP);
      if (computer == null)
        return;
      computer.hostileActionTaken();
    }

    public override void Update(float t)
    {
      base.Update(t);
      Rectangle rectangle = new Rectangle(this.bounds.X + 1, this.bounds.Y + Module.PANEL_HEIGHT + 1, this.bounds.Width - 2, this.bounds.Height - Module.PANEL_HEIGHT - 2);
      this.heightRange = (float) ((rectangle.Height - 4 - 17) / 3) * 2f;
      float y = Math.Max(1f, (float) ((double) rectangle.Height - 4.0 - 17.0));
      this.graphPoints[0] = new Vector2(this.graphPoints[0].X, y);
      this.backGraphPoints[0] = new Vector2(this.backGraphPoints[0].X, y);
      this.graphPoints[this.graphPoints.Count - 1] = new Vector2(this.graphPoints[this.graphPoints.Count - 1].X, y);
      this.backGraphPoints[this.backGraphPoints.Count - 1] = new Vector2(this.backGraphPoints[this.backGraphPoints.Count - 1].X, y);
      this.progress += t / HTTPExploitExe.DURATION;
      if ((double) this.progress >= 1.0)
      {
        this.progress = 1f;
        if (!this.hasCompleted)
        {
          this.Completed();
          this.hasCompleted = true;
        }
        this.sucsessTimer -= t;
        if ((double) this.sucsessTimer <= 0.0)
          this.isExiting = true;
      }
      else
      {
        this.tAccum += t * 1.5f;
        this.fastTimeAccum += t * 4f;
      }
      for (int index = 1; index < this.graphPoints.Count - 1; ++index)
      {
        Vector2 vector2 = this.graphPoints[index];
        float num1 = Math.Abs(vector2.Y - this.heightRange / 2f) / (this.heightRange / 2f);
        float num2 = num1 * num1;
        float num3 = 30f - num2;
        float num4 = num2 * (float) ((1.0 - (double) this.progress) * (double) num3 + (double) this.progress * 30.0);
        vector2.Y += (float) Math.Sin((double) this.fastTimeAccum + (double) (index * rectangle.Width)) * HTTPExploitExe.GRAPH_MOVEMENT * num4 * t;
        vector2.Y = Math.Min(vector2.Y, (float) rectangle.Height);
        vector2.Y = Math.Max(vector2.Y, 0.0f);
        this.graphPoints[index] = vector2;
        vector2 = this.backGraphPoints[index];
        float num5 = this.heightRange / 2f - Math.Abs(vector2.Y - this.heightRange / 2f);
        vector2.Y += (float) Math.Sin((double) this.tAccum + (double) (index * rectangle.Width)) * HTTPExploitExe.GRAPH_MOVEMENT * num5 * t;
        this.backGraphPoints[index] = vector2;
      }
    }

    public override void Draw(float t)
    {
      base.Draw(t);
      this.drawOutline();
      this.drawTarget("app:");
      Rectangle destinationRectangle = this.bounds;
      Rectangle bounds = this.bounds;
      destinationRectangle = new Rectangle(this.bounds.X + 1, this.bounds.Y + Module.PANEL_HEIGHT + 1, this.bounds.Width - 2, this.bounds.Height - Module.PANEL_HEIGHT - 2);
      this.bounds = destinationRectangle = destinationRectangle;
      Vector2 vector2 = new Vector2((float) this.bounds.X, (float) this.bounds.Y);
      for (int index = 0; index < this.graphPoints.Count - 1; ++index)
      {
        Vector2 backGraphPoint1 = this.backGraphPoints[index];
        Vector2 backGraphPoint2 = this.backGraphPoints[index + 1];
        backGraphPoint1.Y = Math.Min(backGraphPoint1.Y, (float) this.bounds.Height);
        backGraphPoint1.Y = Math.Max(backGraphPoint1.Y, 0.0f);
        backGraphPoint2.Y = Math.Min(backGraphPoint2.Y, this.heightRange);
        backGraphPoint2.Y = Math.Max(backGraphPoint2.Y, 0.0f);
        this.drawLine(backGraphPoint1 + vector2, backGraphPoint2 + vector2, this.os.subtleTextColor);
      }
      for (int index = 0; index < this.graphPoints.Count - 1; ++index)
        this.drawLine(this.graphPoints[index] + vector2, this.graphPoints[index + 1] + vector2, Color.White);
      destinationRectangle.X += 2;
      destinationRectangle.Width -= 4;
      destinationRectangle.Y = this.bounds.Y + this.bounds.Height - 1 - 13;
      destinationRectangle.Height = 13;
      this.spriteBatch.Draw(Utils.white, destinationRectangle, this.os.outlineColor * this.fade);
      ++destinationRectangle.X;
      ++destinationRectangle.Y;
      destinationRectangle.Width -= 2;
      destinationRectangle.Height -= 2;
      this.spriteBatch.Draw(Utils.white, destinationRectangle, Color.White * this.fade);
      destinationRectangle.Width = (int) ((double) destinationRectangle.Width * (double) this.progress);
      this.spriteBatch.Draw(Utils.white, destinationRectangle, this.os.highlightColor * this.fade);
      this.bounds = bounds;
    }

    public void drawLine(Vector2 origin, Vector2 dest, Color c)
    {
      float y = Vector2.Distance(origin, dest);
      float rotation = (float) Math.Atan2((double) dest.Y - (double) origin.Y, (double) dest.X - (double) origin.X) + 4.712389f;
      this.spriteBatch.Draw(Utils.white, origin, new Rectangle?(), c * this.fade, rotation, Vector2.Zero, new Vector2(1f, y), SpriteEffects.None, 0.5f);
    }

    public override void Completed()
    {
      base.Completed();
      Computer computer = Programs.getComputer(this.os, this.targetIP);
      if (computer == null)
        return;
      computer.openPort(80, this.os.thisComputer.ip);
    }
  }
}
